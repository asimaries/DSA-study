{
  "CPP": {
    "prefix": "u",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define endl '\\n'",
      "#define INF 1000000000",
      "#define lINF 100000000000000000",
      "#define int long long",
      "#define ld long double",
      "#define ull unsigned long long",
      "#define mod 1000000007",
      "#define PI 3.141592653589793238462",
      "#define sz(x) ((int)(x).size())",
      "#define gri greater<int>()",
      "#define all(x) (x).begin(), (x).end()",
      "/*-------------------ASIMARIES--------------------*/",
      "void asimaries();",
      "",
      "signed main()",
      "{",
      "#ifndef ONLINE_JUDGE",
      "    freopen(\"in.in\", \"r\", stdin);",
      "    freopen(\"out.in\", \"w\", stdout);",
      "#endif",
      "cout << fixed << setprecision(6);",
      "",
      "    int t = 1;",
      "    cin >> t;",
      "    while (t--)",
      "    {",
      "        asimaries();",
      "        cout << endl;",
      "    }",
      "    return 0;",
      "}",
      "/*-----------------ASIMARIES----------------*/",
      "",
      "void asimaries()",
      "{",
      "    $1",
      "}",
      ""
    ],
    "description": "CPP"
  },
  "debug": {
    "prefix": "dbg",
    "body": ["debug($1);"],
    "description": "debug"
  },
  "vector": {
    "prefix": "vec",
    "body": ["vector <$1> ();"],
    "description": "vector<>"
  },
  "set": {
    "prefix": "st",
    "body": ["set <$1> st;"],
    "description": "set<>"
  },
  "map": {
    "prefix": "mp",
    "body": ["map <$1, $2> mp;"],
    "description": "map<>"
  },
  "pair": {
    "prefix": "pr",
    "body": ["pair <$1, $2> ;"],
    "description": "pair<>"
  },
  "stack": {
    "prefix": "stk",
    "body": ["stack <$1> stk;"],
    "description": "stack<>"
  },
  "queue": {
    "prefix": "qu",
    "body": ["queue <$1> q;"],
    "description": "queue<>"
  },
  "deque": {
    "prefix": "dq",
    "body": ["deque <$1> dq;"],
    "description": "deque<>"
  },
  "sort": {
    "prefix": "sor",
    "body": ["sort(all($1));"],
    "description": "sort()"
  },
  "Node": {
    "prefix": "node",
    "body": ["Node *"],
    "description": "Node *"
  },
  "vector<vector<T>>": {
    "prefix": "vvec",
    "body": ["vector<vector<$1>> $2($3, vector<$1>($4));"],
    "description": "vector<vector<>>"
  },
  "TESTCASES": {
    "prefix": "test",
    "body": ["int t;", "cin >> t;", "while (t--)", "{", "    $1", "}"],
    "description": "TESTCASES"
  },
  "SIEVE": {
    "prefix": "SIEVE",
    "body": [
      "vector<bool> __PRIME;",
      "void __sieve(int n = 1000009)",
      "{",
      "    __PRIME.resize(n + 1, true);",
      "    __PRIME[0] = __PRIME[1] = 0;",
      "    int sqtn = sqrt(n);",
      "    for (int p = 2; p <= sqtn; p++)",
      "        if (__PRIME[p])",
      "            for (int i = p * p; i <= n; i += p)",
      "                __PRIME[i] = false;",
      "    return;",
      "}"
    ],
    "description": "SIEVE OF ERATOSTHENES"
  },
  "DEBUG": {
    "prefix": "DEBUG",
    "body": [
      "#define debug(x)                    \\",
      "    cerr << #x << \" = \", _print(x); \\",
      "    cerr << endl;",
      "void _print(int t) { cerr << t; }",
      "void _print(string t) { cerr << t; }",
      "void _print(char t) { cerr << t; }",
      "void _print(ld t) { cerr << t; }",
      "void _print(double t) { cerr << t; }",
      "void _print(ull t) { cerr << t; }",
      "template <class T, class V>",
      "void _print(pair<T, V> p);",
      "template <class T>",
      "void _print(vector<T> v);",
      "template <class T>",
      "void _print(set<T> v);",
      "template <class T, class V>",
      "void _print(map<T, V> v);",
      "template <class T>",
      "void _print(multiset<T> v);",
      "template <class T, class V>",
      "void _print(pair<T, V> p) { cerr << \"{\", _print(p.first), cerr << \" ,\", _print(p.second), cerr << \"}\\n\"; }",
      "template <class T>",
      "void _print(vector<T> v)",
      "{",
      "    cerr << \"[ \";",
      "    for (T i : v)",
      "        _print(i), cerr << \" \";",
      "    cerr << \"]\\n\";",
      "}",
      "template <class T>",
      "void _print(set<T> v)",
      "{",
      "    cerr << \"[ \";",
      "    for (T i : v)",
      "        _print(i), cerr << \" \";",
      "    cerr << \"]\\n\";",
      "}",
      "template <class T>",
      "void _print(multiset<T> v)",
      "{",
      "    cerr << \"[ \";",
      "    for (T i : v)",
      "        _print(i), cerr << \" \";",
      "    cerr << \"]\\n\";",
      "}",
      "template <class T, class V>",
      "void _print(map<T, V> v)",
      "{",
      "    cerr << \"[\\n\";",
      "    for (auto i : v)",
      "        _print(i), cerr << \"\\n\";",
      "    cerr << \"]\\n\";",
      "}",
      "template <class T>",
      "void printArr(vector<T> v)",
      "{",
      "    for (auto i : v)",
      "        cout << i << \" \";",
      "}",
      "template <class T>",
      "void printArr(vector<vector<T>> v)",
      "{",
      "    for (auto i : v)",
      "    {",
      "        printArr(i);",
      "    }",
      "}",
      "/*----------------ASIMARIES-----------------*/"
    ],
    "description": "DEBUGGER"
  },
  "DIVISORS": {
    "prefix": "DIVISORS",
    "body": [
      "vector<int> getDIVISORS(int n)",
      "{",
      "    vector<int> ans;",
      "    int sqt = sqrt(n);",
      "    for (int i = 1; i <= sqt; i++)",
      "        if (n % i == 0)",
      "            if (n / i == i)",
      "                ans.emplace_back(i);",
      "            else",
      "                ans.emplace_back(n / i);",
      "",
      "    return ans;",
      "}"
    ],
    "description": "DIVISORS"
  },
  "Extended Euclid": {
    "prefix": "exEuclid",
    "body": [
      "class Triplet",
      "{",
      "public:",
      "    int x, y, gcd;",
      "    Triplet(int _x, int _y, int _gcd) { x = _x, y = _y, gcd = _gcd; }",
      "};",
      "Triplet exEuclid(int a, int b)",
      "{",
      "    if (b == 0)",
      "    {",
      "        Triplet ans(1, 0, a);",
      "        return ans;",
      "    }",
      "    Triplet dash = exEuclid(b, a % b);",
      "    Triplet ans(dash.y, (dash.x - ((a / b) * dash.y)), dash.gcd);",
      "    return ans;",
      "}",
      "int modInverse(int a, int m)",
      "{",
      "    int x = exEuclid(a, m).x;",
      "    return (x % m + m) % m;",
      "}",
      ""
    ],
    "description": "Extended Euclid"
  }
}
